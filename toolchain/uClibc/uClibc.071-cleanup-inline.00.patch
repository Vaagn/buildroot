Index: uClibc/libm/e_lgamma_r.c
===================================================================
--- uClibc/libm/e_lgamma_r.c	(revision 23764)
+++ uClibc/libm/e_lgamma_r.c	(working copy)
@@ -164,7 +164,7 @@ static double zero=  0.00000000000000000
 
 static
 #ifdef __GNUC__
-inline
+__inline__
 #endif
 #ifdef __STDC__
 	double sin_pi(double x)
Index: uClibc/ldso/ldso/arm/dl-startup.h
===================================================================
--- uClibc/ldso/ldso/arm/dl-startup.h	(revision 23764)
+++ uClibc/ldso/ldso/arm/dl-startup.h	(working copy)
@@ -136,7 +136,7 @@ __asm__(
 #define GET_ARGV(ARGVP, ARGS) ARGVP = (((unsigned long*)ARGS)+1)
 
 /* Handle relocation of the symbols in the dynamic loader. */
-static inline
+static __always_inline
 void PERFORM_BOOTSTRAP_RELOC(ELF_RELOC *rpnt, unsigned long *reloc_addr,
 	unsigned long symbol_addr, unsigned long load_addr, Elf32_Sym *symtab)
 {
Index: uClibc/ldso/ldso/frv/dl-syscalls.h
===================================================================
--- uClibc/ldso/ldso/frv/dl-syscalls.h	(revision 23764)
+++ uClibc/ldso/ldso/frv/dl-syscalls.h	(working copy)
@@ -30,8 +30,8 @@ static __inline__ _syscall6(__ptr_t, __s
 # endif
 
 #include <bits/uClibc_page.h> /* for PAGE_SIZE */
-inline static void *_dl_memset(void*,int,size_t);
-inline static ssize_t _dl_pread(int fd, void *buf, size_t count, off_t offset);
+static __always_inline void *_dl_memset(void*,int,size_t);
+static __always_inline ssize_t _dl_pread(int fd, void *buf, size_t count, off_t offset);
 
 static __ptr_t
 _dl_mmap(__ptr_t addr, size_t len, int prot, int flags, int fd, __off_t offset)
@@ -138,11 +138,11 @@ _dl_mmap(__ptr_t addr, size_t len, int p
 #include <unistd.h>
 
 #define __NR___syscall_lseek __NR_lseek
-inline static unsigned long _dl_read(int fd, const void *buf, unsigned long count);
+static __always_inline unsigned long _dl_read(int fd, const void *buf, unsigned long count);
 
-inline static _syscall3(__off_t, __syscall_lseek, int, fd, __off_t, offset,
+static __always_inline _syscall3(__off_t, __syscall_lseek, int, fd, __off_t, offset,
 			int, whence);
-inline static ssize_t
+static __always_inline ssize_t
 _dl_pread(int fd, void *buf, size_t count, off_t offset)
 {
   __off_t orig = __syscall_lseek (fd, 0, SEEK_CUR);
@@ -163,10 +163,10 @@ _dl_pread(int fd, void *buf, size_t coun
 }
 #else
 #define __NR___syscall_pread __NR_pread
-inline static _syscall5(ssize_t, __syscall_pread, int, fd, void *, buf,
+static __always_inline _syscall5(ssize_t, __syscall_pread, int, fd, void *, buf,
 			size_t, count, off_t, offset_hi, off_t, offset_lo);
 
-inline static ssize_t
+static __always_inline ssize_t
 _dl_pread(int fd, void *buf, size_t count, off_t offset)
 {
   return(__syscall_pread(fd,buf,count,__LONG_LONG_PAIR (offset >> 31, offset)));
Index: uClibc/ldso/ldso/frv/dl-inlines.h
===================================================================
--- uClibc/ldso/ldso/frv/dl-inlines.h	(revision 23764)
+++ uClibc/ldso/ldso/frv/dl-inlines.h	(working copy)
@@ -10,7 +10,7 @@
 
 /* Initialize a DL_LOADADDR_TYPE given a got pointer and a complete
    load map.  */
-inline static void
+static __always_inline void
 __dl_init_loadaddr_map (struct elf32_fdpic_loadaddr *loadaddr, void *got_value,
 			struct elf32_fdpic_loadmap *map)
 {
@@ -31,7 +31,7 @@ __dl_init_loadaddr_map (struct elf32_fdp
 /* Figure out how many LOAD segments there are in the given headers,
    and allocate a block for the load map big enough for them.
    got_value will be properly initialized later on, with INIT_GOT.  */
-inline static int
+static __always_inline int
 __dl_init_loadaddr (struct elf32_fdpic_loadaddr *loadaddr, Elf32_Phdr *ppnt,
 		    int pcnt)
 {
@@ -57,7 +57,7 @@ __dl_init_loadaddr (struct elf32_fdpic_l
 }
 
 /* Incrementally initialize a load map.  */
-inline static void
+static __always_inline void
 __dl_init_loadaddr_hdr (struct elf32_fdpic_loadaddr loadaddr, void *addr,
 			Elf32_Phdr *phdr, int maxsegs)
 {
@@ -83,12 +83,12 @@ __dl_init_loadaddr_hdr (struct elf32_fdp
 #endif
 }
 
-inline static void __dl_loadaddr_unmap
+static __always_inline void __dl_loadaddr_unmap
 (struct elf32_fdpic_loadaddr loadaddr, struct funcdesc_ht *funcdesc_ht);
 
 /* Figure out whether the given address is in one of the mapped
    segments.  */
-inline static int
+static __always_inline int
 __dl_addr_in_loadaddr (void *p, struct elf32_fdpic_loadaddr loadaddr)
 {
   struct elf32_fdpic_loadmap *map = loadaddr.map;
@@ -102,7 +102,7 @@ __dl_addr_in_loadaddr (void *p, struct e
   return 0;
 }
 
-inline static void * _dl_funcdesc_for (void *entry_point, void *got_value);
+static __always_inline void * _dl_funcdesc_for (void *entry_point, void *got_value);
 
 /* The hashcode handling code below is heavily inspired in libiberty's
    hashtab code, but with most adaptation points and support for
@@ -111,7 +111,7 @@ inline static void * _dl_funcdesc_for (v
    Copyright (C) 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
    Contributed by Vladimir Makarov (vmakarov@cygnus.com).  */
 
-inline static unsigned long
+static __always_inline unsigned long
 higher_prime_number (unsigned long n)
 {
   /* These are primes that are near, but slightly smaller than, a
@@ -186,13 +186,13 @@ struct funcdesc_ht
   size_t n_elements;
 };
 
-inline static int
+static __always_inline int
 hash_pointer (const void *p)
 {
   return (int) ((long)p >> 3);
 }
 
-inline static struct funcdesc_ht *
+static __always_inline struct funcdesc_ht *
 htab_create (void)
 {
   struct funcdesc_ht *ht = _dl_malloc (sizeof (struct funcdesc_ht));
@@ -213,7 +213,7 @@ htab_create (void)
 
 /* This is only called from _dl_loadaddr_unmap, so it's safe to call
    _dl_free().  See the discussion below.  */
-inline static void
+static __always_inline void
 htab_delete (struct funcdesc_ht *htab)
 {
   int i;
@@ -233,7 +233,7 @@ htab_delete (struct funcdesc_ht *htab)
    This function also assumes there are no deleted entries in the table.
    HASH is the hash value for the element to be inserted.  */
 
-inline static struct funcdesc_value **
+static __always_inline struct funcdesc_value **
 find_empty_slot_for_expand (struct funcdesc_ht *htab, int hash)
 {
   size_t size = htab->size;
@@ -265,7 +265,7 @@ find_empty_slot_for_expand (struct funcd
    this function will return zero, indicating that the table could not be
    expanded.  If all goes well, it will return a non-zero value.  */
 
-inline static int
+static __always_inline int
 htab_expand (struct funcdesc_ht *htab)
 {
   struct funcdesc_value **oentries;
@@ -323,7 +323,7 @@ htab_expand (struct funcdesc_ht *htab)
    When inserting an entry, NULL may be returned if memory allocation
    fails.  */
 
-inline static struct funcdesc_value **
+static __always_inline struct funcdesc_value **
 htab_find_slot (struct funcdesc_ht *htab, void *ptr, int insert)
 {
   unsigned int index;
@@ -399,7 +399,7 @@ _dl_funcdesc_for (void *entry_point, voi
   return _dl_stabilize_funcdesc (*entry);
 }
 
-inline static void const *
+static __always_inline void const *
 _dl_lookup_address (void const *address)
 {
   struct elf_resolve *rpnt;
Index: uClibc/ldso/ldso/cris/dl-startup.h
===================================================================
--- uClibc/ldso/ldso/cris/dl-startup.h	(revision 23764)
+++ uClibc/ldso/ldso/cris/dl-startup.h	(working copy)
@@ -53,7 +53,7 @@ __asm__(""					\
 
 
 /* Handle relocation of the symbols in the dynamic loader. */
-static inline
+static __always_inline
 void PERFORM_BOOTSTRAP_RELOC(ELF_RELOC *rpnt, unsigned long *reloc_addr,
 	unsigned long symbol_addr, unsigned long load_addr, Elf32_Sym *symtab)
 {
Index: uClibc/ldso/ldso/sh/dl-syscalls.h
===================================================================
--- uClibc/ldso/ldso/sh/dl-syscalls.h	(revision 23764)
+++ uClibc/ldso/ldso/sh/dl-syscalls.h	(working copy)
@@ -9,6 +9,6 @@ extern int _dl_errno;
 #warning !!! gcc 4.1 and later have problems with __always_inline so redefined as inline
 # ifdef __always_inline
 # undef __always_inline
-# define __always_inline inline
+# define __always_inline __inline__
 # endif
 #endif
Index: uClibc/ldso/ldso/bfin/dl-syscalls.h
===================================================================
--- uClibc/ldso/ldso/bfin/dl-syscalls.h	(revision 23764)
+++ uClibc/ldso/ldso/bfin/dl-syscalls.h	(working copy)
@@ -44,8 +44,8 @@ static __inline__ _syscall6(__ptr_t, __s
 # endif
 
 #include <bits/uClibc_page.h> /* for PAGE_SIZE */
-inline static void *_dl_memset(void*,int,size_t);
-inline static ssize_t _dl_pread(int fd, void *buf, size_t count, off_t offset);
+static __always_inline void *_dl_memset(void*,int,size_t);
+static __always_inline ssize_t _dl_pread(int fd, void *buf, size_t count, off_t offset);
 
 static __ptr_t
 _dl_mmap(__ptr_t addr, size_t len, int prot, int flags, int fd, __off_t offset)
@@ -152,11 +152,11 @@ _dl_mmap(__ptr_t addr, size_t len, int p
 #include <unistd.h>
 
 #define __NR___syscall_lseek __NR_lseek
-inline static unsigned long _dl_read(int fd, const void *buf, unsigned long count);
+static __always_inline unsigned long _dl_read(int fd, const void *buf, unsigned long count);
 
-inline static _syscall3(__off_t, __syscall_lseek, int, fd, __off_t, offset,
+static __always_inline _syscall3(__off_t, __syscall_lseek, int, fd, __off_t, offset,
 			int, whence);
-inline static ssize_t
+static __always_inline ssize_t
 _dl_pread(int fd, void *buf, size_t count, off_t offset)
 {
   __off_t orig = __syscall_lseek (fd, 0, SEEK_CUR);
@@ -177,10 +177,10 @@ _dl_pread(int fd, void *buf, size_t coun
 }
 #else
 #define __NR___syscall_pread __NR_pread
-inline static _syscall5(ssize_t, __syscall_pread, int, fd, void *, buf,
+static __always_inline _syscall5(ssize_t, __syscall_pread, int, fd, void *, buf,
 			size_t, count, off_t, offset_hi, off_t, offset_lo);
 
-inline static ssize_t
+static __always_inline ssize_t
 _dl_pread(int fd, void *buf, size_t count, off_t offset)
 {
   return(__syscall_pread(fd,buf,count,__LONG_LONG_PAIR (offset >> 31, offset)));
@@ -190,18 +190,18 @@ _dl_pread(int fd, void *buf, size_t coun
 
 #ifdef __NR_sram_alloc
 #define __NR__dl_sram_alloc __NR_sram_alloc
-inline static _syscall2(__ptr_t, _dl_sram_alloc,
+static __always_inline _syscall2(__ptr_t, _dl_sram_alloc,
 			size_t, len, unsigned long, flags);
 #endif
 
 #ifdef __NR_sram_free
 #define __NR__dl_sram_free __NR_sram_free
-inline static _syscall1(int, _dl_sram_free, __ptr_t, addr);
+static __always_inline _syscall1(int, _dl_sram_free, __ptr_t, addr);
 #endif
 
 #ifdef __NR_dma_memcpy
 #define __NR__dl_dma_memcpy __NR_dma_memcpy
-inline static _syscall3(__ptr_t, _dl_dma_memcpy,
+static __always_inline _syscall3(__ptr_t, _dl_dma_memcpy,
 			__ptr_t, dest, __ptr_t, src, size_t, len);
 #endif
 
Index: uClibc/ldso/ldso/bfin/dl-inlines.h
===================================================================
--- uClibc/ldso/ldso/bfin/dl-inlines.h	(revision 23764)
+++ uClibc/ldso/ldso/bfin/dl-inlines.h	(working copy)
@@ -26,7 +26,7 @@ USA.  */
 
 /* Initialize a DL_LOADADDR_TYPE given a got pointer and a complete
    load map.  */
-inline static void
+static __always_inline void
 __dl_init_loadaddr_map (struct elf32_fdpic_loadaddr *loadaddr, Elf32_Addr dl_boot_got_pointer,
 			struct elf32_fdpic_loadmap *map)
 {
@@ -47,7 +47,7 @@ __dl_init_loadaddr_map (struct elf32_fdp
 /* Figure out how many LOAD segments there are in the given headers,
    and allocate a block for the load map big enough for them.
    got_value will be properly initialized later on, with INIT_GOT.  */
-inline static int
+static __always_inline int
 __dl_init_loadaddr (struct elf32_fdpic_loadaddr *loadaddr, Elf32_Phdr *ppnt,
 		    int pcnt)
 {
@@ -73,7 +73,7 @@ __dl_init_loadaddr (struct elf32_fdpic_l
 }
 
 /* Incrementally initialize a load map.  */
-inline static void
+static __always_inline void
 __dl_init_loadaddr_hdr (struct elf32_fdpic_loadaddr loadaddr, void *addr,
 			Elf32_Phdr *phdr, int maxsegs)
 {
@@ -99,12 +99,12 @@ __dl_init_loadaddr_hdr (struct elf32_fdp
 #endif
 }
 
-inline static void __dl_loadaddr_unmap
+static __always_inline void __dl_loadaddr_unmap
 (struct elf32_fdpic_loadaddr loadaddr, struct funcdesc_ht *funcdesc_ht);
 
 /* Figure out whether the given address is in one of the mapped
    segments.  */
-inline static int
+static __always_inline int
 __dl_addr_in_loadaddr (void *p, struct elf32_fdpic_loadaddr loadaddr)
 {
   struct elf32_fdpic_loadmap *map = loadaddr.map;
@@ -118,7 +118,7 @@ __dl_addr_in_loadaddr (void *p, struct e
   return 0;
 }
 
-inline static void * _dl_funcdesc_for (void *entry_point, void *got_value);
+static __always_inline void * _dl_funcdesc_for (void *entry_point, void *got_value);
 
 /* The hashcode handling code below is heavily inspired in libiberty's
    hashtab code, but with most adaptation points and support for
@@ -127,7 +127,7 @@ inline static void * _dl_funcdesc_for (v
    Copyright (C) 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
    Contributed by Vladimir Makarov (vmakarov@cygnus.com).  */
 
-inline static unsigned long
+static __always_inline unsigned long
 higher_prime_number (unsigned long n)
 {
   /* These are primes that are near, but slightly smaller than, a
@@ -202,13 +202,13 @@ struct funcdesc_ht
   size_t n_elements;
 };
 
-inline static int
+static __always_inline int
 hash_pointer (const void *p)
 {
   return (int) ((long)p >> 3);
 }
 
-inline static struct funcdesc_ht *
+static __always_inline struct funcdesc_ht *
 htab_create (void)
 {
   struct funcdesc_ht *ht = _dl_malloc (sizeof (struct funcdesc_ht));
@@ -229,7 +229,7 @@ htab_create (void)
 
 /* This is only called from _dl_loadaddr_unmap, so it's safe to call
    _dl_free().  See the discussion below.  */
-inline static void
+static __always_inline void
 htab_delete (struct funcdesc_ht *htab)
 {
   int i;
@@ -249,7 +249,7 @@ htab_delete (struct funcdesc_ht *htab)
    This function also assumes there are no deleted entries in the table.
    HASH is the hash value for the element to be inserted.  */
 
-inline static struct funcdesc_value **
+static __always_inline struct funcdesc_value **
 find_empty_slot_for_expand (struct funcdesc_ht *htab, int hash)
 {
   size_t size = htab->size;
@@ -281,7 +281,7 @@ find_empty_slot_for_expand (struct funcd
    this function will return zero, indicating that the table could not be
    expanded.  If all goes well, it will return a non-zero value.  */
 
-inline static int
+static __always_inline int
 htab_expand (struct funcdesc_ht *htab)
 {
   struct funcdesc_value **oentries;
@@ -339,7 +339,7 @@ htab_expand (struct funcdesc_ht *htab)
    When inserting an entry, NULL may be returned if memory allocation
    fails.  */
 
-inline static struct funcdesc_value **
+static __always_inline struct funcdesc_value **
 htab_find_slot (struct funcdesc_ht *htab, void *ptr, int insert)
 {
   unsigned int index;
@@ -415,7 +415,7 @@ _dl_funcdesc_for (void *entry_point, voi
   return _dl_stabilize_funcdesc (*entry);
 }
 
-inline static void const *
+static __always_inline void const *
 _dl_lookup_address (void const *address)
 {
   struct elf_resolve *rpnt;
@@ -487,7 +487,7 @@ __dl_loadaddr_unmap (struct elf32_fdpic_
     htab_delete (funcdesc_ht);
 }
 
-inline static int
+static __always_inline int
 __dl_is_special_segment (Elf32_Ehdr *epnt,
 			 Elf32_Phdr *ppnt)
 {
@@ -515,7 +515,7 @@ __dl_is_special_segment (Elf32_Ehdr *epn
   return 0;
 }
 
-inline static char *
+static __always_inline char *
 __dl_map_segment (Elf32_Ehdr *epnt,
 		  Elf32_Phdr *ppnt,
 		  int infile,
Index: uClibc/libc/stdlib/stdlib.c
===================================================================
--- uClibc/libc/stdlib/stdlib.c	(revision 23764)
+++ uClibc/libc/stdlib/stdlib.c	(working copy)
@@ -936,7 +936,7 @@ libc_hidden_def(_stdlib_mb_cur_max)
  * To note, until now all the supported encoding are stateless.
  */
 
-static inline int is_stateful(unsigned char encoding)
+static __always_inline int is_stateful(unsigned char encoding)
 {
 	switch (encoding)
 	{
Index: uClibc/libc/sysdeps/linux/powerpc/ioctl.c
===================================================================
--- uClibc/libc/sysdeps/linux/powerpc/ioctl.c	(revision 23764)
+++ uClibc/libc/sysdeps/linux/powerpc/ioctl.c	(working copy)
@@ -31,7 +31,7 @@ libc_hidden_proto(tcgetattr)
    using the new-style struct termios, and translate them to old-style.  */
 
 #define __NR___syscall_ioctl __NR_ioctl
-static inline
+static __always_inline
 _syscall3(int, __syscall_ioctl, int, fd, unsigned long int, request, void *, arg)
 
 
Index: uClibc/libc/sysdeps/linux/common/sysctl.c
===================================================================
--- uClibc/libc/sysdeps/linux/common/sysctl.c	(revision 23764)
+++ uClibc/libc/sysdeps/linux/common/sysctl.c	(working copy)
@@ -24,7 +24,7 @@ struct __sysctl_args {
 	unsigned long __unused[4];
 };
 
-static inline
+static __always_inline
 _syscall1(int, _sysctl, struct __sysctl_args *, args)
 
 int sysctl(int *name, int nlen, void *oldval, size_t * oldlenp,
Index: uClibc/libc/sysdeps/linux/common/getcwd.c
===================================================================
--- uClibc/libc/sysdeps/linux/common/getcwd.c	(revision 23764)
+++ uClibc/libc/sysdeps/linux/common/getcwd.c	(working copy)
@@ -30,7 +30,7 @@ libc_hidden_proto(stat)
 #ifdef __NR_getcwd
 
 # define __NR___syscall_getcwd __NR_getcwd
-static inline
+static __always_inline
 _syscall2(int, __syscall_getcwd, char *, buf, unsigned long, size)
 
 #else
@@ -144,7 +144,7 @@ oops:
 	return 0;
 }
 
-static inline
+static __always_inline
 int __syscall_getcwd(char * buf, unsigned long size)
 {
     int len;
Index: uClibc/libc/sysdeps/linux/common/getdents.c
===================================================================
--- uClibc/libc/sysdeps/linux/common/getdents.c	(revision 23764)
+++ uClibc/libc/sysdeps/linux/common/getdents.c	(working copy)
@@ -39,7 +39,7 @@ struct kernel_dirent
 ssize_t __getdents (int fd, char *buf, size_t nbytes) attribute_hidden;
 
 #define __NR___syscall_getdents __NR_getdents
-static inline _syscall3(int, __syscall_getdents, int, fd, unsigned char *, kdirp, size_t, count);
+static __always_inline _syscall3(int, __syscall_getdents, int, fd, unsigned char *, kdirp, size_t, count);
 
 #ifdef __ASSUME_GETDENTS32_D_TYPE
 ssize_t __getdents (int fd, char *buf, size_t nbytes)
Index: uClibc/libc/sysdeps/linux/common/sigprocmask.c
===================================================================
--- uClibc/libc/sysdeps/linux/common/sigprocmask.c	(revision 23764)
+++ uClibc/libc/sysdeps/linux/common/sigprocmask.c	(working copy)
@@ -19,7 +19,7 @@ libc_hidden_proto(sigprocmask)
 #ifdef __NR_rt_sigprocmask
 
 # define __NR___rt_sigprocmask __NR_rt_sigprocmask
-static inline
+static __always_inline
 _syscall4(int, __rt_sigprocmask, int, how, const sigset_t *, set,
 		  sigset_t *, oldset, size_t, size)
 
@@ -46,7 +46,7 @@ int sigprocmask(int how, const sigset_t 
 #else
 
 # define __NR___syscall_sigprocmask __NR_sigprocmask
-static inline
+static __always_inline
 _syscall3(int, __syscall_sigprocmask, int, how, const sigset_t *, set,
 		  sigset_t *, oldset)
 
Index: uClibc/libc/sysdeps/linux/common/ppoll.c
===================================================================
--- uClibc/libc/sysdeps/linux/common/ppoll.c	(revision 23764)
+++ uClibc/libc/sysdeps/linux/common/ppoll.c	(working copy)
@@ -25,7 +25,7 @@
 libc_hidden_proto(ppoll)
 
 # define __NR___libc_ppoll __NR_ppoll
-static inline
+static __always_inline
 _syscall4(int, __libc_ppoll, struct pollfd *, fds,
 	nfds_t, nfds, const struct timespec *, timeout,
 	const __sigset_t *, sigmask)
Index: uClibc/libc/sysdeps/linux/common/ioctl.c
===================================================================
--- uClibc/libc/sysdeps/linux/common/ioctl.c	(revision 23764)
+++ uClibc/libc/sysdeps/linux/common/ioctl.c	(working copy)
@@ -14,7 +14,7 @@
 libc_hidden_proto(ioctl)
 
 #define __NR___syscall_ioctl __NR_ioctl
-static inline
+static __always_inline
 _syscall3(int, __syscall_ioctl, int, fd, int, request, void *, arg)
 
 int ioctl(int fd, unsigned long int request, ...)
Index: uClibc/libc/sysdeps/linux/common/getrlimit.c
===================================================================
--- uClibc/libc/sysdeps/linux/common/getrlimit.c	(revision 23764)
+++ uClibc/libc/sysdeps/linux/common/getrlimit.c	(working copy)
@@ -21,7 +21,7 @@ libc_hidden_proto(getrlimit)
 
 /* just call ugetrlimit() */
 # define __NR___syscall_ugetrlimit __NR_ugetrlimit
-static inline
+static __always_inline
 _syscall2(int, __syscall_ugetrlimit, enum __rlimit_resource, resource,
           struct rlimit *, rlim)
 int getrlimit(__rlimit_resource_t resource, struct rlimit *rlimits)
@@ -39,7 +39,7 @@ _syscall2(int, getrlimit, __rlimit_resou
 
 /* we have to handle old style getrlimit() */
 # define __NR___syscall_getrlimit __NR_getrlimit
-static inline
+static __always_inline
 _syscall2(int, __syscall_getrlimit, int, resource, struct rlimit *, rlim)
 
 int getrlimit(__rlimit_resource_t resource, struct rlimit *rlimits)
Index: uClibc/libc/sysdeps/linux/common/setrlimit.c
===================================================================
--- uClibc/libc/sysdeps/linux/common/setrlimit.c	(revision 23764)
+++ uClibc/libc/sysdeps/linux/common/setrlimit.c	(working copy)
@@ -21,7 +21,7 @@ libc_hidden_proto(setrlimit)
 
 /* just call usetrlimit() */
 # define __NR___syscall_usetrlimit __NR_usetrlimit
-static inline
+static __always_inline
 _syscall2(int, __syscall_usetrlimit, enum __rlimit_resource, resource,
           const struct rlimit *, rlim)
 int setrlimit(__rlimit_resource_t resource, struct rlimit *rlimits)
@@ -39,7 +39,7 @@ _syscall2(int, setrlimit, __rlimit_resou
 
 /* we have to handle old style setrlimit() */
 # define __NR___syscall_setrlimit __NR_setrlimit
-static inline
+static __always_inline
 _syscall2(int, __syscall_setrlimit, int, resource, const struct rlimit *, rlim)
 
 int setrlimit(__rlimit_resource_t resource, const struct rlimit *rlimits)
Index: uClibc/libc/sysdeps/linux/common/__syscall_fcntl.c
===================================================================
--- uClibc/libc/sysdeps/linux/common/__syscall_fcntl.c	(revision 23764)
+++ uClibc/libc/sysdeps/linux/common/__syscall_fcntl.c	(working copy)
@@ -21,7 +21,7 @@ libc_hidden_proto(__libc_fcntl64)
 #endif
 
 #define __NR___syscall_fcntl __NR_fcntl
-static inline
+static __always_inline
 _syscall3(int, __syscall_fcntl, int, fd, int, cmd, long, arg)
 
 int __libc_fcntl(int fd, int cmd, ...)
Index: uClibc/libc/sysdeps/linux/frv/crtreloc.c
===================================================================
--- uClibc/libc/sysdeps/linux/frv/crtreloc.c	(revision 23764)
+++ uClibc/libc/sysdeps/linux/frv/crtreloc.c	(working copy)
@@ -34,7 +34,7 @@ Cambridge, MA 02139, USA.  */
 
 /* Compute the runtime address of pointer in the range [p,e), and then
    map the pointer pointed by it.  */
-inline static void ***
+static __always_inline void ***
 reloc_range_indirect (void ***p, void ***e,
 		      const struct elf32_fdpic_loadmap *map)
 {
@@ -79,7 +79,7 @@ __self_reloc (const struct elf32_fdpic_l
    need.  */
 
 /* Remap pointers in [p,e).  */
-inline static void**
+static __always_inline void**
 reloc_range (void **p, void **e,
 	     const struct elf32_fdpic_loadmap *map)
 {
Index: uClibc/libc/sysdeps/linux/frv/bits/elf-fdpic.h
===================================================================
--- uClibc/libc/sysdeps/linux/frv/bits/elf-fdpic.h	(revision 23764)
+++ uClibc/libc/sysdeps/linux/frv/bits/elf-fdpic.h	(working copy)
@@ -64,7 +64,7 @@ struct elf32_fdpic_loadaddr {
 
 /* Map a pointer's VMA to its corresponding address according to the
    load map.  */
-inline static void *
+static __always_inline void *
 __reloc_pointer (void *p,
 		 const struct elf32_fdpic_loadmap *map)
 {
Index: uClibc/libc/sysdeps/linux/e1/bits/fenvinline.h
===================================================================
--- uClibc/libc/sysdeps/linux/e1/bits/fenvinline.h	(revision 23764)
+++ uClibc/libc/sysdeps/linux/e1/bits/fenvinline.h	(working copy)
@@ -124,7 +124,7 @@ static __inline__ feclearexcept(int __ex
  * excepts. You can test for an exception either after
  * an FP instruction or within a SIGFPE handler
  */
-inline int fetestexcept(int __excepts)
+__inline__ int fetestexcept(int __excepts)
 {
 	unsigned int G2, G2en, G2dis;
 	unsigned int enabled_excepts, disabled_excepts;
Index: uClibc/libc/sysdeps/linux/bfin/crtreloc.c
===================================================================
--- uClibc/libc/sysdeps/linux/bfin/crtreloc.c	(revision 23764)
+++ uClibc/libc/sysdeps/linux/bfin/crtreloc.c	(working copy)
@@ -41,7 +41,7 @@ union word {
 
 /* Compute the runtime address of pointer in the range [p,e), and then
    map the pointer pointed by it.  */
-inline static void ***
+static __always_inline void ***
 reloc_range_indirect (void ***p, void ***e,
 		      const struct elf32_fdpic_loadmap *map)
 {
@@ -102,7 +102,7 @@ __self_reloc (const struct elf32_fdpic_l
    need.  */
 
 /* Remap pointers in [p,e).  */
-inline static void**
+static __always_inline void**
 reloc_range (void **p, void **e,
 	     const struct elf32_fdpic_loadmap *map)
 {
Index: uClibc/libc/sysdeps/linux/bfin/bits/elf-fdpic.h
===================================================================
--- uClibc/libc/sysdeps/linux/bfin/bits/elf-fdpic.h	(revision 23764)
+++ uClibc/libc/sysdeps/linux/bfin/bits/elf-fdpic.h	(working copy)
@@ -64,7 +64,7 @@ struct elf32_fdpic_loadaddr {
 
 /* Map a pointer's VMA to its corresponding address according to the
    load map.  */
-inline static void *
+static __always_inline void *
 __reloc_pointer (void *p,
 		 const struct elf32_fdpic_loadmap *map)
 {
Index: uClibc/libpthread/linuxthreads/sysdeps/unix/sysv/linux/allocalim.h
===================================================================
--- uClibc/libpthread/linuxthreads/sysdeps/unix/sysv/linux/allocalim.h	(revision 23764)
+++ uClibc/libpthread/linuxthreads/sysdeps/unix/sysv/linux/allocalim.h	(working copy)
@@ -19,7 +19,7 @@
 
 #include <limits.h>
 
-extern inline int __libc_use_alloca (size_t size)
+__extern_always_inline int __libc_use_alloca (size_t size)
 {
   return (__builtin_expect (size <= PTHREAD_STACK_MIN / 4, 1)
 	  || __libc_alloca_cutoff (size));
